// Code generated by counterfeiter. DO NOT EDIT.
package fake

import (
	"context"
	"sync"

	pgx "github.com/jackc/pgx/v5"
	"github.com/jackc/pgx/v5/pgconn"
)

type Tx struct {
	BeginStub        func(context.Context) (pgx.Tx, error)
	beginMutex       sync.RWMutex
	beginArgsForCall []struct {
		arg1 context.Context
	}
	beginReturns struct {
		result1 pgx.Tx
		result2 error
	}
	beginReturnsOnCall map[int]struct {
		result1 pgx.Tx
		result2 error
	}
	CommitStub        func(context.Context) error
	commitMutex       sync.RWMutex
	commitArgsForCall []struct {
		arg1 context.Context
	}
	commitReturns struct {
		result1 error
	}
	commitReturnsOnCall map[int]struct {
		result1 error
	}
	ConnStub        func() *pgx.Conn
	connMutex       sync.RWMutex
	connArgsForCall []struct {
	}
	connReturns struct {
		result1 *pgx.Conn
	}
	connReturnsOnCall map[int]struct {
		result1 *pgx.Conn
	}
	CopyFromStub        func(context.Context, pgx.Identifier, []string, pgx.CopyFromSource) (int64, error)
	copyFromMutex       sync.RWMutex
	copyFromArgsForCall []struct {
		arg1 context.Context
		arg2 pgx.Identifier
		arg3 []string
		arg4 pgx.CopyFromSource
	}
	copyFromReturns struct {
		result1 int64
		result2 error
	}
	copyFromReturnsOnCall map[int]struct {
		result1 int64
		result2 error
	}
	ExecStub        func(context.Context, string, ...any) (pgconn.CommandTag, error)
	execMutex       sync.RWMutex
	execArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 []any
	}
	execReturns struct {
		result1 pgconn.CommandTag
		result2 error
	}
	execReturnsOnCall map[int]struct {
		result1 pgconn.CommandTag
		result2 error
	}
	LargeObjectsStub        func() pgx.LargeObjects
	largeObjectsMutex       sync.RWMutex
	largeObjectsArgsForCall []struct {
	}
	largeObjectsReturns struct {
		result1 pgx.LargeObjects
	}
	largeObjectsReturnsOnCall map[int]struct {
		result1 pgx.LargeObjects
	}
	PrepareStub        func(context.Context, string, string) (*pgconn.StatementDescription, error)
	prepareMutex       sync.RWMutex
	prepareArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}
	prepareReturns struct {
		result1 *pgconn.StatementDescription
		result2 error
	}
	prepareReturnsOnCall map[int]struct {
		result1 *pgconn.StatementDescription
		result2 error
	}
	QueryStub        func(context.Context, string, ...any) (pgx.Rows, error)
	queryMutex       sync.RWMutex
	queryArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 []any
	}
	queryReturns struct {
		result1 pgx.Rows
		result2 error
	}
	queryReturnsOnCall map[int]struct {
		result1 pgx.Rows
		result2 error
	}
	QueryRowStub        func(context.Context, string, ...any) pgx.Row
	queryRowMutex       sync.RWMutex
	queryRowArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 []any
	}
	queryRowReturns struct {
		result1 pgx.Row
	}
	queryRowReturnsOnCall map[int]struct {
		result1 pgx.Row
	}
	RollbackStub        func(context.Context) error
	rollbackMutex       sync.RWMutex
	rollbackArgsForCall []struct {
		arg1 context.Context
	}
	rollbackReturns struct {
		result1 error
	}
	rollbackReturnsOnCall map[int]struct {
		result1 error
	}
	SendBatchStub        func(context.Context, *pgx.Batch) pgx.BatchResults
	sendBatchMutex       sync.RWMutex
	sendBatchArgsForCall []struct {
		arg1 context.Context
		arg2 *pgx.Batch
	}
	sendBatchReturns struct {
		result1 pgx.BatchResults
	}
	sendBatchReturnsOnCall map[int]struct {
		result1 pgx.BatchResults
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *Tx) Begin(arg1 context.Context) (pgx.Tx, error) {
	fake.beginMutex.Lock()
	ret, specificReturn := fake.beginReturnsOnCall[len(fake.beginArgsForCall)]
	fake.beginArgsForCall = append(fake.beginArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	stub := fake.BeginStub
	fakeReturns := fake.beginReturns
	fake.recordInvocation("Begin", []interface{}{arg1})
	fake.beginMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *Tx) BeginCallCount() int {
	fake.beginMutex.RLock()
	defer fake.beginMutex.RUnlock()
	return len(fake.beginArgsForCall)
}

func (fake *Tx) BeginCalls(stub func(context.Context) (pgx.Tx, error)) {
	fake.beginMutex.Lock()
	defer fake.beginMutex.Unlock()
	fake.BeginStub = stub
}

func (fake *Tx) BeginArgsForCall(i int) context.Context {
	fake.beginMutex.RLock()
	defer fake.beginMutex.RUnlock()
	argsForCall := fake.beginArgsForCall[i]
	return argsForCall.arg1
}

func (fake *Tx) BeginReturns(result1 pgx.Tx, result2 error) {
	fake.beginMutex.Lock()
	defer fake.beginMutex.Unlock()
	fake.BeginStub = nil
	fake.beginReturns = struct {
		result1 pgx.Tx
		result2 error
	}{result1, result2}
}

func (fake *Tx) BeginReturnsOnCall(i int, result1 pgx.Tx, result2 error) {
	fake.beginMutex.Lock()
	defer fake.beginMutex.Unlock()
	fake.BeginStub = nil
	if fake.beginReturnsOnCall == nil {
		fake.beginReturnsOnCall = make(map[int]struct {
			result1 pgx.Tx
			result2 error
		})
	}
	fake.beginReturnsOnCall[i] = struct {
		result1 pgx.Tx
		result2 error
	}{result1, result2}
}

func (fake *Tx) Commit(arg1 context.Context) error {
	fake.commitMutex.Lock()
	ret, specificReturn := fake.commitReturnsOnCall[len(fake.commitArgsForCall)]
	fake.commitArgsForCall = append(fake.commitArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	stub := fake.CommitStub
	fakeReturns := fake.commitReturns
	fake.recordInvocation("Commit", []interface{}{arg1})
	fake.commitMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *Tx) CommitCallCount() int {
	fake.commitMutex.RLock()
	defer fake.commitMutex.RUnlock()
	return len(fake.commitArgsForCall)
}

func (fake *Tx) CommitCalls(stub func(context.Context) error) {
	fake.commitMutex.Lock()
	defer fake.commitMutex.Unlock()
	fake.CommitStub = stub
}

func (fake *Tx) CommitArgsForCall(i int) context.Context {
	fake.commitMutex.RLock()
	defer fake.commitMutex.RUnlock()
	argsForCall := fake.commitArgsForCall[i]
	return argsForCall.arg1
}

func (fake *Tx) CommitReturns(result1 error) {
	fake.commitMutex.Lock()
	defer fake.commitMutex.Unlock()
	fake.CommitStub = nil
	fake.commitReturns = struct {
		result1 error
	}{result1}
}

func (fake *Tx) CommitReturnsOnCall(i int, result1 error) {
	fake.commitMutex.Lock()
	defer fake.commitMutex.Unlock()
	fake.CommitStub = nil
	if fake.commitReturnsOnCall == nil {
		fake.commitReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.commitReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *Tx) Conn() *pgx.Conn {
	fake.connMutex.Lock()
	ret, specificReturn := fake.connReturnsOnCall[len(fake.connArgsForCall)]
	fake.connArgsForCall = append(fake.connArgsForCall, struct {
	}{})
	stub := fake.ConnStub
	fakeReturns := fake.connReturns
	fake.recordInvocation("Conn", []interface{}{})
	fake.connMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *Tx) ConnCallCount() int {
	fake.connMutex.RLock()
	defer fake.connMutex.RUnlock()
	return len(fake.connArgsForCall)
}

func (fake *Tx) ConnCalls(stub func() *pgx.Conn) {
	fake.connMutex.Lock()
	defer fake.connMutex.Unlock()
	fake.ConnStub = stub
}

func (fake *Tx) ConnReturns(result1 *pgx.Conn) {
	fake.connMutex.Lock()
	defer fake.connMutex.Unlock()
	fake.ConnStub = nil
	fake.connReturns = struct {
		result1 *pgx.Conn
	}{result1}
}

func (fake *Tx) ConnReturnsOnCall(i int, result1 *pgx.Conn) {
	fake.connMutex.Lock()
	defer fake.connMutex.Unlock()
	fake.ConnStub = nil
	if fake.connReturnsOnCall == nil {
		fake.connReturnsOnCall = make(map[int]struct {
			result1 *pgx.Conn
		})
	}
	fake.connReturnsOnCall[i] = struct {
		result1 *pgx.Conn
	}{result1}
}

func (fake *Tx) CopyFrom(arg1 context.Context, arg2 pgx.Identifier, arg3 []string, arg4 pgx.CopyFromSource) (int64, error) {
	var arg3Copy []string
	if arg3 != nil {
		arg3Copy = make([]string, len(arg3))
		copy(arg3Copy, arg3)
	}
	fake.copyFromMutex.Lock()
	ret, specificReturn := fake.copyFromReturnsOnCall[len(fake.copyFromArgsForCall)]
	fake.copyFromArgsForCall = append(fake.copyFromArgsForCall, struct {
		arg1 context.Context
		arg2 pgx.Identifier
		arg3 []string
		arg4 pgx.CopyFromSource
	}{arg1, arg2, arg3Copy, arg4})
	stub := fake.CopyFromStub
	fakeReturns := fake.copyFromReturns
	fake.recordInvocation("CopyFrom", []interface{}{arg1, arg2, arg3Copy, arg4})
	fake.copyFromMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *Tx) CopyFromCallCount() int {
	fake.copyFromMutex.RLock()
	defer fake.copyFromMutex.RUnlock()
	return len(fake.copyFromArgsForCall)
}

func (fake *Tx) CopyFromCalls(stub func(context.Context, pgx.Identifier, []string, pgx.CopyFromSource) (int64, error)) {
	fake.copyFromMutex.Lock()
	defer fake.copyFromMutex.Unlock()
	fake.CopyFromStub = stub
}

func (fake *Tx) CopyFromArgsForCall(i int) (context.Context, pgx.Identifier, []string, pgx.CopyFromSource) {
	fake.copyFromMutex.RLock()
	defer fake.copyFromMutex.RUnlock()
	argsForCall := fake.copyFromArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *Tx) CopyFromReturns(result1 int64, result2 error) {
	fake.copyFromMutex.Lock()
	defer fake.copyFromMutex.Unlock()
	fake.CopyFromStub = nil
	fake.copyFromReturns = struct {
		result1 int64
		result2 error
	}{result1, result2}
}

func (fake *Tx) CopyFromReturnsOnCall(i int, result1 int64, result2 error) {
	fake.copyFromMutex.Lock()
	defer fake.copyFromMutex.Unlock()
	fake.CopyFromStub = nil
	if fake.copyFromReturnsOnCall == nil {
		fake.copyFromReturnsOnCall = make(map[int]struct {
			result1 int64
			result2 error
		})
	}
	fake.copyFromReturnsOnCall[i] = struct {
		result1 int64
		result2 error
	}{result1, result2}
}

func (fake *Tx) Exec(arg1 context.Context, arg2 string, arg3 ...any) (pgconn.CommandTag, error) {
	fake.execMutex.Lock()
	ret, specificReturn := fake.execReturnsOnCall[len(fake.execArgsForCall)]
	fake.execArgsForCall = append(fake.execArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 []any
	}{arg1, arg2, arg3})
	stub := fake.ExecStub
	fakeReturns := fake.execReturns
	fake.recordInvocation("Exec", []interface{}{arg1, arg2, arg3})
	fake.execMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *Tx) ExecCallCount() int {
	fake.execMutex.RLock()
	defer fake.execMutex.RUnlock()
	return len(fake.execArgsForCall)
}

func (fake *Tx) ExecCalls(stub func(context.Context, string, ...any) (pgconn.CommandTag, error)) {
	fake.execMutex.Lock()
	defer fake.execMutex.Unlock()
	fake.ExecStub = stub
}

func (fake *Tx) ExecArgsForCall(i int) (context.Context, string, []any) {
	fake.execMutex.RLock()
	defer fake.execMutex.RUnlock()
	argsForCall := fake.execArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *Tx) ExecReturns(result1 pgconn.CommandTag, result2 error) {
	fake.execMutex.Lock()
	defer fake.execMutex.Unlock()
	fake.ExecStub = nil
	fake.execReturns = struct {
		result1 pgconn.CommandTag
		result2 error
	}{result1, result2}
}

func (fake *Tx) ExecReturnsOnCall(i int, result1 pgconn.CommandTag, result2 error) {
	fake.execMutex.Lock()
	defer fake.execMutex.Unlock()
	fake.ExecStub = nil
	if fake.execReturnsOnCall == nil {
		fake.execReturnsOnCall = make(map[int]struct {
			result1 pgconn.CommandTag
			result2 error
		})
	}
	fake.execReturnsOnCall[i] = struct {
		result1 pgconn.CommandTag
		result2 error
	}{result1, result2}
}

func (fake *Tx) LargeObjects() pgx.LargeObjects {
	fake.largeObjectsMutex.Lock()
	ret, specificReturn := fake.largeObjectsReturnsOnCall[len(fake.largeObjectsArgsForCall)]
	fake.largeObjectsArgsForCall = append(fake.largeObjectsArgsForCall, struct {
	}{})
	stub := fake.LargeObjectsStub
	fakeReturns := fake.largeObjectsReturns
	fake.recordInvocation("LargeObjects", []interface{}{})
	fake.largeObjectsMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *Tx) LargeObjectsCallCount() int {
	fake.largeObjectsMutex.RLock()
	defer fake.largeObjectsMutex.RUnlock()
	return len(fake.largeObjectsArgsForCall)
}

func (fake *Tx) LargeObjectsCalls(stub func() pgx.LargeObjects) {
	fake.largeObjectsMutex.Lock()
	defer fake.largeObjectsMutex.Unlock()
	fake.LargeObjectsStub = stub
}

func (fake *Tx) LargeObjectsReturns(result1 pgx.LargeObjects) {
	fake.largeObjectsMutex.Lock()
	defer fake.largeObjectsMutex.Unlock()
	fake.LargeObjectsStub = nil
	fake.largeObjectsReturns = struct {
		result1 pgx.LargeObjects
	}{result1}
}

func (fake *Tx) LargeObjectsReturnsOnCall(i int, result1 pgx.LargeObjects) {
	fake.largeObjectsMutex.Lock()
	defer fake.largeObjectsMutex.Unlock()
	fake.LargeObjectsStub = nil
	if fake.largeObjectsReturnsOnCall == nil {
		fake.largeObjectsReturnsOnCall = make(map[int]struct {
			result1 pgx.LargeObjects
		})
	}
	fake.largeObjectsReturnsOnCall[i] = struct {
		result1 pgx.LargeObjects
	}{result1}
}

func (fake *Tx) Prepare(arg1 context.Context, arg2 string, arg3 string) (*pgconn.StatementDescription, error) {
	fake.prepareMutex.Lock()
	ret, specificReturn := fake.prepareReturnsOnCall[len(fake.prepareArgsForCall)]
	fake.prepareArgsForCall = append(fake.prepareArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.PrepareStub
	fakeReturns := fake.prepareReturns
	fake.recordInvocation("Prepare", []interface{}{arg1, arg2, arg3})
	fake.prepareMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *Tx) PrepareCallCount() int {
	fake.prepareMutex.RLock()
	defer fake.prepareMutex.RUnlock()
	return len(fake.prepareArgsForCall)
}

func (fake *Tx) PrepareCalls(stub func(context.Context, string, string) (*pgconn.StatementDescription, error)) {
	fake.prepareMutex.Lock()
	defer fake.prepareMutex.Unlock()
	fake.PrepareStub = stub
}

func (fake *Tx) PrepareArgsForCall(i int) (context.Context, string, string) {
	fake.prepareMutex.RLock()
	defer fake.prepareMutex.RUnlock()
	argsForCall := fake.prepareArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *Tx) PrepareReturns(result1 *pgconn.StatementDescription, result2 error) {
	fake.prepareMutex.Lock()
	defer fake.prepareMutex.Unlock()
	fake.PrepareStub = nil
	fake.prepareReturns = struct {
		result1 *pgconn.StatementDescription
		result2 error
	}{result1, result2}
}

func (fake *Tx) PrepareReturnsOnCall(i int, result1 *pgconn.StatementDescription, result2 error) {
	fake.prepareMutex.Lock()
	defer fake.prepareMutex.Unlock()
	fake.PrepareStub = nil
	if fake.prepareReturnsOnCall == nil {
		fake.prepareReturnsOnCall = make(map[int]struct {
			result1 *pgconn.StatementDescription
			result2 error
		})
	}
	fake.prepareReturnsOnCall[i] = struct {
		result1 *pgconn.StatementDescription
		result2 error
	}{result1, result2}
}

func (fake *Tx) Query(arg1 context.Context, arg2 string, arg3 ...any) (pgx.Rows, error) {
	fake.queryMutex.Lock()
	ret, specificReturn := fake.queryReturnsOnCall[len(fake.queryArgsForCall)]
	fake.queryArgsForCall = append(fake.queryArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 []any
	}{arg1, arg2, arg3})
	stub := fake.QueryStub
	fakeReturns := fake.queryReturns
	fake.recordInvocation("Query", []interface{}{arg1, arg2, arg3})
	fake.queryMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *Tx) QueryCallCount() int {
	fake.queryMutex.RLock()
	defer fake.queryMutex.RUnlock()
	return len(fake.queryArgsForCall)
}

func (fake *Tx) QueryCalls(stub func(context.Context, string, ...any) (pgx.Rows, error)) {
	fake.queryMutex.Lock()
	defer fake.queryMutex.Unlock()
	fake.QueryStub = stub
}

func (fake *Tx) QueryArgsForCall(i int) (context.Context, string, []any) {
	fake.queryMutex.RLock()
	defer fake.queryMutex.RUnlock()
	argsForCall := fake.queryArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *Tx) QueryReturns(result1 pgx.Rows, result2 error) {
	fake.queryMutex.Lock()
	defer fake.queryMutex.Unlock()
	fake.QueryStub = nil
	fake.queryReturns = struct {
		result1 pgx.Rows
		result2 error
	}{result1, result2}
}

func (fake *Tx) QueryReturnsOnCall(i int, result1 pgx.Rows, result2 error) {
	fake.queryMutex.Lock()
	defer fake.queryMutex.Unlock()
	fake.QueryStub = nil
	if fake.queryReturnsOnCall == nil {
		fake.queryReturnsOnCall = make(map[int]struct {
			result1 pgx.Rows
			result2 error
		})
	}
	fake.queryReturnsOnCall[i] = struct {
		result1 pgx.Rows
		result2 error
	}{result1, result2}
}

func (fake *Tx) QueryRow(arg1 context.Context, arg2 string, arg3 ...any) pgx.Row {
	fake.queryRowMutex.Lock()
	ret, specificReturn := fake.queryRowReturnsOnCall[len(fake.queryRowArgsForCall)]
	fake.queryRowArgsForCall = append(fake.queryRowArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 []any
	}{arg1, arg2, arg3})
	stub := fake.QueryRowStub
	fakeReturns := fake.queryRowReturns
	fake.recordInvocation("QueryRow", []interface{}{arg1, arg2, arg3})
	fake.queryRowMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *Tx) QueryRowCallCount() int {
	fake.queryRowMutex.RLock()
	defer fake.queryRowMutex.RUnlock()
	return len(fake.queryRowArgsForCall)
}

func (fake *Tx) QueryRowCalls(stub func(context.Context, string, ...any) pgx.Row) {
	fake.queryRowMutex.Lock()
	defer fake.queryRowMutex.Unlock()
	fake.QueryRowStub = stub
}

func (fake *Tx) QueryRowArgsForCall(i int) (context.Context, string, []any) {
	fake.queryRowMutex.RLock()
	defer fake.queryRowMutex.RUnlock()
	argsForCall := fake.queryRowArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *Tx) QueryRowReturns(result1 pgx.Row) {
	fake.queryRowMutex.Lock()
	defer fake.queryRowMutex.Unlock()
	fake.QueryRowStub = nil
	fake.queryRowReturns = struct {
		result1 pgx.Row
	}{result1}
}

func (fake *Tx) QueryRowReturnsOnCall(i int, result1 pgx.Row) {
	fake.queryRowMutex.Lock()
	defer fake.queryRowMutex.Unlock()
	fake.QueryRowStub = nil
	if fake.queryRowReturnsOnCall == nil {
		fake.queryRowReturnsOnCall = make(map[int]struct {
			result1 pgx.Row
		})
	}
	fake.queryRowReturnsOnCall[i] = struct {
		result1 pgx.Row
	}{result1}
}

func (fake *Tx) Rollback(arg1 context.Context) error {
	fake.rollbackMutex.Lock()
	ret, specificReturn := fake.rollbackReturnsOnCall[len(fake.rollbackArgsForCall)]
	fake.rollbackArgsForCall = append(fake.rollbackArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	stub := fake.RollbackStub
	fakeReturns := fake.rollbackReturns
	fake.recordInvocation("Rollback", []interface{}{arg1})
	fake.rollbackMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *Tx) RollbackCallCount() int {
	fake.rollbackMutex.RLock()
	defer fake.rollbackMutex.RUnlock()
	return len(fake.rollbackArgsForCall)
}

func (fake *Tx) RollbackCalls(stub func(context.Context) error) {
	fake.rollbackMutex.Lock()
	defer fake.rollbackMutex.Unlock()
	fake.RollbackStub = stub
}

func (fake *Tx) RollbackArgsForCall(i int) context.Context {
	fake.rollbackMutex.RLock()
	defer fake.rollbackMutex.RUnlock()
	argsForCall := fake.rollbackArgsForCall[i]
	return argsForCall.arg1
}

func (fake *Tx) RollbackReturns(result1 error) {
	fake.rollbackMutex.Lock()
	defer fake.rollbackMutex.Unlock()
	fake.RollbackStub = nil
	fake.rollbackReturns = struct {
		result1 error
	}{result1}
}

func (fake *Tx) RollbackReturnsOnCall(i int, result1 error) {
	fake.rollbackMutex.Lock()
	defer fake.rollbackMutex.Unlock()
	fake.RollbackStub = nil
	if fake.rollbackReturnsOnCall == nil {
		fake.rollbackReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.rollbackReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *Tx) SendBatch(arg1 context.Context, arg2 *pgx.Batch) pgx.BatchResults {
	fake.sendBatchMutex.Lock()
	ret, specificReturn := fake.sendBatchReturnsOnCall[len(fake.sendBatchArgsForCall)]
	fake.sendBatchArgsForCall = append(fake.sendBatchArgsForCall, struct {
		arg1 context.Context
		arg2 *pgx.Batch
	}{arg1, arg2})
	stub := fake.SendBatchStub
	fakeReturns := fake.sendBatchReturns
	fake.recordInvocation("SendBatch", []interface{}{arg1, arg2})
	fake.sendBatchMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *Tx) SendBatchCallCount() int {
	fake.sendBatchMutex.RLock()
	defer fake.sendBatchMutex.RUnlock()
	return len(fake.sendBatchArgsForCall)
}

func (fake *Tx) SendBatchCalls(stub func(context.Context, *pgx.Batch) pgx.BatchResults) {
	fake.sendBatchMutex.Lock()
	defer fake.sendBatchMutex.Unlock()
	fake.SendBatchStub = stub
}

func (fake *Tx) SendBatchArgsForCall(i int) (context.Context, *pgx.Batch) {
	fake.sendBatchMutex.RLock()
	defer fake.sendBatchMutex.RUnlock()
	argsForCall := fake.sendBatchArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *Tx) SendBatchReturns(result1 pgx.BatchResults) {
	fake.sendBatchMutex.Lock()
	defer fake.sendBatchMutex.Unlock()
	fake.SendBatchStub = nil
	fake.sendBatchReturns = struct {
		result1 pgx.BatchResults
	}{result1}
}

func (fake *Tx) SendBatchReturnsOnCall(i int, result1 pgx.BatchResults) {
	fake.sendBatchMutex.Lock()
	defer fake.sendBatchMutex.Unlock()
	fake.SendBatchStub = nil
	if fake.sendBatchReturnsOnCall == nil {
		fake.sendBatchReturnsOnCall = make(map[int]struct {
			result1 pgx.BatchResults
		})
	}
	fake.sendBatchReturnsOnCall[i] = struct {
		result1 pgx.BatchResults
	}{result1}
}

func (fake *Tx) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.beginMutex.RLock()
	defer fake.beginMutex.RUnlock()
	fake.commitMutex.RLock()
	defer fake.commitMutex.RUnlock()
	fake.connMutex.RLock()
	defer fake.connMutex.RUnlock()
	fake.copyFromMutex.RLock()
	defer fake.copyFromMutex.RUnlock()
	fake.execMutex.RLock()
	defer fake.execMutex.RUnlock()
	fake.largeObjectsMutex.RLock()
	defer fake.largeObjectsMutex.RUnlock()
	fake.prepareMutex.RLock()
	defer fake.prepareMutex.RUnlock()
	fake.queryMutex.RLock()
	defer fake.queryMutex.RUnlock()
	fake.queryRowMutex.RLock()
	defer fake.queryRowMutex.RUnlock()
	fake.rollbackMutex.RLock()
	defer fake.rollbackMutex.RUnlock()
	fake.sendBatchMutex.RLock()
	defer fake.sendBatchMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *Tx) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ pgx.Tx = new(Tx)
